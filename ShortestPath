# Python3 code for creating the shortest path between vertices
# Keep in mind the graph is weighted and undirected, we will use Dijkstra's algorithm and the adjacency matrix
# to find the shortest path in the graph
import sys

# First we must define the adjacency matrix that we want to use, we will use the matrix from example one
adjacency_matrix = [
    [0, 5, 0, 5, 0, 0, 10],
    [5, 0, 0, 20, 10, 0, 0],
    [0, 0, 0, 0, 15, 1, 0],
    [5, 20, 0, 0, 0, 0, 0],
    [0, 10, 15, 0, 0, 30, 0],
    [0, 0, 1, 0, 30, 0, 25],
    [10, 0, 0, 0, 0, 25, 0]
]


class shortestPaths:
    # at our starting vertex (node) there is no previous or parent so
    NO_PREVIOUS = -1
    shortest_path = []
    queue = []
    distance = queue


# Calculate the shortest path using Dijkstra's algorithim, where the time complexity is O(n^2)
def shortest_path(current, adjacency_matrix, start, final):
    x = len(adjacency_matrix[0])
    shortest = []
    visited = []
    previous = []
    for v in range(0, x, 1):
        shortest[x] = sys.maxsize
        visited[x] = False
    shortest[start] = 0
    previous[start] = start.NO_PREVIOUS
    for i in range(1, x, 1):
        pre = -1
        min = sys.maxsize

        for v in range(0, x, 1):
            if visited[v] == False and shortest[v] < min:
                pre = v
                min = shortest[v]
            if pre = -1:
                return
            visited[pre] = True
            for v in range(0, x, 1):
                dist = adjacency_matrix[pre][v]
                if dist > 0 and ((min + dist) < shortest[v]):
                    previous[v] = pre
                    shortest[v] = min + dist
    current.distance.add(shortest[final])
    current.addPath(final, previous)

# Recursive function to add the shortest path of our nodes into our queue
def add_shortest_path(current, i, previous) :
    if i == current.NO_PARENT:
        return
    current.addPath(previous[i], previous)
    current.path.append(i)

# Now using Dijkstra's algorithm we remove each edge in the shortest path and compare them
def find_second_shortest(current, adjacency_matrix, start, final) :
    #store the previous' vertex data